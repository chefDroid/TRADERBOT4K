 DISCORD-BOT INDEX AND COMMANDS
 INDEX.JS
 
  
  
  
  
  require("dotenv").config();
const { Client, GatewayIntentBits, EmbedBuilder } = require("discord.js");
const axios = require("axios");

const client = new Client({ intents: [GatewayIntentBits.Guilds] });

const SPORTS = {
  nba: "basketball_nba",
  nfl: "americanfootball_nfl",
  nhl: "icehockey_nhl",
  cfb: "americanfootball_ncaaf",
  cbb: "basketball_ncaab",
  boxing: "boxing",
  mma: "mma_mixed_martial_arts"
};

const ODDS_URL = "https://api.the-odds-api.com/v4/sports";

/* ---------------- HELPERS ---------------- */

async function getOdds(sportKey) {
  try {
    const res = await fetch(
      `https://api.the-odds-api.com/v4/sports/${sportKey}/odds/?regions=us&markets=h2h&apiKey=${proc>
    );
    const data = await res.json();
    return Array.isArray(data) ? data : [];
  } catch {
    return [];
  }

function bestOutcome(game) {
  const market = game.bookmakers?.[0]?.markets?.[0];
  if (!market) return null;
  return market.outcomes.sort((a, b) => a.price - b.price)[0];
}

function splitBankroll(bankroll, legs) {
  return {
    straight: (bankroll * 0.5).toFixed(2),
    threeLeg: (bankroll * 0.3).toFixed(2),
    fullParlay: (bankroll * 0.2).toFixed(2),
    perLeg: (bankroll / legs).toFixed(2)
  };
}

/* ---------------- READY ---------------- */

client.once("ready", () => {
  console.log(`âœ… Logged in as ${client.user.tag}`);
});

/* ---------------- COMMANDS ---------------- */

client.on("interactionCreate", async interaction => {
  if (!interaction.isChatInputCommand()) return;

  await interaction.deferReply();

  try {
    const { commandName, options } = interaction;

    /* ================= PICK ================= */
    if (commandName === "pick") {
      const sub = options.getSubcommand(false) || "default";

      let games = [];

      if (sub === "query") {
        const search = options.getString("search").toLowerCase();
        for (const k in SPORTS) {
          const g = await fetchOdds(SPORTS[k]);
          const match = g.find(x =>
            `${x.home_team} ${x.away_team}`.toLowerCase().includes(search)
          );
          if (match) {
            const pick = bestOutcome(match);
            if (!pick) continue;
            return interaction.editReply({
              embeds: [
                new EmbedBuilder()
                  .setTitle("ðŸ” Pick Lookup")
                  .setDescription(`${match.home_team} vs ${match.away_team}`)
                  .addFields(
                    { name: "Pick", value: pick.name },
                    { name: "Odds", value: pick.price.toString() },
                    { name: "Sport", value: k.toUpperCase() }
                  )
              ]
            });
          }
        }
        return interaction.editReply("âŒ No matching team or player found.");
      }

      if (sub === "default") {
        for (const k in SPORTS) {
          games.push(...await fetchOdds(SPORTS[k]));
        }
      } else {
        games = await fetchOdds(SPORTS[sub]);
      }

      if (!games.length) {
        return interaction.editReply("âŒ No games available today.");
      }

      const game = games[Math.floor(Math.random() * games.length)];
      const pick = bestOutcome(game);
      if (!pick) return interaction.editReply("âŒ No valid odds found.");

      return interaction.editReply({
        embeds: [
          new EmbedBuilder()
            .setTitle("ðŸŽ¯ Todayâ€™s Pick")
            .setDescription(`${game.home_team} vs ${game.away_team}`)
            .addFields(
              { name: "Pick", value: pick.name },
              { name: "Odds", value: pick.price.toString() },
              { name: "Source", value: sub.toUpperCase() }
            )
        ]
      });
    }

    /* ================= BUILD ================= */
    if (commandName === "build") {
      const legs = options.getInteger("legs") || 3;
      const bankroll = options.getInteger("bankroll") || 20;
      const mode = options.getString("mode") || "parlay";
      const live = options.getBoolean("live") || false;

      let games = [];
      for (const k in SPORTS) {
        games.push(...await fetchOdds(SPORTS[k]));
      }

      const picks = games
        .map(g => ({ game: g, pick: bestOutcome(g) }))
        .filter(p => p.pick)
        .slice(0, legs);

      if (!picks.length) {
        return interaction.editReply("âŒ No games available to build.");
      }

      const split = splitBankroll(bankroll, legs);

      const embed = new EmbedBuilder()
        .setTitle("ðŸ§± Parlay Builder")
        .setDescription(`${mode.toUpperCase()} â€¢ ${legs} Legs`);

      picks.forEach((p, i) => {
        embed.addFields({
          name: `Leg ${i + 1}`,
          value: `${p.pick.name} (${p.pick.price})`
        });
      });

      embed.addFields({
        name: "ðŸ’° Allocation",
        value:
          mode === "straight"
            ? `Straight Bet: $${split.straight}`
            : `
Straight: $${split.straight}
3-Leg: $${split.threeLeg}
Full Parlay: $${split.fullParlay}
`
      });

      return interaction.editReply({ embeds: [embed] });
    }

    /* ================= UNDERDOG ================= */
    if (commandName === "underdog") {
      const bankroll = options.getInteger("bankroll") || 20;

      let games = [];
      for (const k in SPORTS) {
        games.push(...await fetchOdds(SPORTS[k]));
      }

      const picks = games
        .map(g => ({ game: g, pick: bestOutcome(g) }))
        .filter(p => p.pick)
        .slice(0, 7);

      if (!picks.length) {
        return interaction.editReply("âŒ No underdog picks today.");
      }

      const split = splitBankroll(bankroll, 7);

      const embed = new EmbedBuilder()
        .setTitle("ðŸ”¥ Underdog Aggressive Strategy")
        .setDescription("Lucky 7 ðŸ€");

      picks.forEach((p, i) => {
        embed.addFields({
          name: `Leg ${i + 1}`,
          value: `${p.pick.name} (${p.pick.price})`
        });
      });

      embed.addFields({
        name: "ðŸ’° Bankroll Plan",
        value: `
Straight: $${split.straight}
3-Leg: $${split.threeLeg}
7-Leg Lotto: $${split.fullParlay}
`
      });

      return interaction.editReply({ embeds: [embed] });
    }

    /* ================= CALLEY ================= */
    if (commandName === "calley") {
      const sub = options.getSubcommand(false) || "math";

      if (sub === "math") {
        return interaction.editReply(
          "ðŸ“ Parlay Math: Multiply implied probabilities to estimate payout edge."
        );
      }

      if (sub === "today") {
        let games = [];
        for (const k in SPORTS) {
          games.push(...await fetchOdds(SPORTS[k]));
        }

        const picks = games
          .map(g => ({ game: g, pick: bestOutcome(g) }))
          .filter(p => p.pick)
          .slice(0, 5);

        if (!picks.length) {
          return interaction.editReply("âŒ No picks available.");
        }

        const embed = new EmbedBuilder()
          .setTitle("ðŸ¤– AI-Ranked Picks (Today)");

        picks.forEach((p, i) => {
          embed.addFields({
            name: `Pick ${i + 1}`,
            value: `${p.pick.name} (${p.pick.price})`
          });
        });

        return interaction.editReply({ embeds: [embed] });
      }
    }

  } catch (err) {
    console.error(err);
    return interaction.editReply("âš ï¸ Error handled safely. Bot is still live.");
  }
});

client.login(process.env.DISCORD_TOKEN);
  
 
 
 
 
 
  
  
  
  
  
  
  
  
                    DEPLOY-COMMANDS.JS-SCRIPT:
  
  
  
  
  
  
  
  
  
  
  
  import 'dotenv/config';
import { REST, Routes, SlashCommandBuilder } from 'discord.js';

/* -------- HARD VALIDATION -------- */

if (!process.env.DISCORD_TOKEN) {
  throw new Error('? DISCORD_TOKEN missing from .env');
}

if (!process.env.CLIENT_ID) {
  throw new Error('? CLIENT_ID missing from .env');
}

/* -------- COMMAND DEFINITIONS -------- */

const commands = [
  new SlashCommandBuilder()
    .setName('pick')
    .setDescription('Show live & upcoming games')
    .addStringOption(opt =>
      opt
        .setName('sport')
        .setDescription('Select sport')
        .setRequired(true)
        .addChoices(
          { name: 'NBA', value: 'nba' },
          { name: 'NFL', value: 'nfl' },
          { name: 'NHL', value: 'nhl' },
          { name: 'College Basketball', value: 'ncaam' }
        )
    ),

  new SlashCommandBuilder()
    .setName('build')
    .setDescription('Build a multi-sport parlay'),

  new SlashCommandBuilder()
    .setName('bankroll')
    .setDescription('Bankroll optimizer')
    .addIntegerOption(opt =>
      opt
        .setName('amount')
        .setDescription('Total bankroll')
        .setRequired(true)
    ),

  new SlashCommandBuilder()
    .setName('chat')
    .setDescription('Natural language betting assistant')
    .addStringOption(opt =>
      opt
        .setName('message')
        .setDescription('Ask anything')
        .setRequired(true)
    ),
].map(cmd => cmd.toJSON());

/* -------- DEPLOY -------- */

const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);

(async () => {
  try {
    console.log('? Deploying slash commands...');
    await rest.put(
      Routes.applicationCommands(process.env.CLIENT_ID),
      { body: commands }
    );
    console.log('? Slash commands deployed successfully');
  } catch (err) {
    console.error('? Deploy failed:', err);
  }
})();


NEEDS UPDATE TO /UNDERDOGS SUBCOMMAND & ADD EXTRA

INDEX.JS THAT HAS CORRECT DEPLOY COMMANDS BUT API GAMES DONT APPEAR SHOWS NO GAMES AVAILABLE









INDEX.JS









require("dotenv").config();
const { Client, GatewayIntentBits, EmbedBuilder } = require("discord.js");
const axios = require("axios");

const client = new Client({ intents: [GatewayIntentBits.Guilds] });

const SPORTS = {
  nba: "basketball_nba",
  nfl: "americanfootball_nfl",
  nhl: "icehockey_nhl",
  cfb: "americanfootball_ncaaf",
  cbb: "basketball_ncaab",
  boxing: "boxing",
  mma: "mma_mixed_martial_arts"
};

const ODDS_URL = "https://api.the-odds-api.com/v4/sports";

/* ---------------- HELPERS ---------------- */

async function getOdds(sportKey) {
  try {
    const res = await fetch(
      `https://api.the-odds-api.com/v4/sports/${sportKey}/odds/?regions=us&markets=h2h&apiKey=${proc>
    );
    const data = await res.json();
    return Array.isArray(data) ? data : [];
  } catch {
    return [];
  }

function bestOutcome(game) {
  const market = game.bookmakers?.[0]?.markets?.[0];
  if (!market) return null;
  return market.outcomes.sort((a, b) => a.price - b.price)[0];
}

function splitBankroll(bankroll, legs) {
  return {
    straight: (bankroll * 0.5).toFixed(2),
    threeLeg: (bankroll * 0.3).toFixed(2),
    fullParlay: (bankroll * 0.2).toFixed(2),
    perLeg: (bankroll / legs).toFixed(2)
  };
}

/* ---------------- READY ---------------- */

client.once("ready", () => {
  console.log(`âœ… Logged in as ${client.user.tag}`);
});

/* ---------------- COMMANDS ---------------- */

client.on("interactionCreate", async interaction => {
  if (!interaction.isChatInputCommand()) return;

  await interaction.deferReply();

  try {
    const { commandName, options } = interaction;

    /* ================= PICK ================= */
    if (commandName === "pick") {
      const sub = options.getSubcommand(false) || "default";

      let games = [];

      if (sub === "query") {
        const search = options.getString("search").toLowerCase();
        for (const k in SPORTS) {
          const g = await fetchOdds(SPORTS[k]);
          const match = g.find(x =>
            `${x.home_team} ${x.away_team}`.toLowerCase().includes(search)
          );
          if (match) {
            const pick = bestOutcome(match);
            if (!pick) continue;
            return interaction.editReply({
              embeds: [
                new EmbedBuilder()
                  .setTitle("ðŸ” Pick Lookup")
                  .setDescription(`${match.home_team} vs ${match.away_team}`)
                  .addFields(
                    { name: "Pick", value: pick.name },
                    { name: "Odds", value: pick.price.toString() },
                    { name: "Sport", value: k.toUpperCase() }
                  )
              ]
            });
          }
        }
        return interaction.editReply("âŒ No matching team or player found.");
      }

      if (sub === "default") {
        for (const k in SPORTS) {
          games.push(...await fetchOdds(SPORTS[k]));
        }
      } else {
        games = await fetchOdds(SPORTS[sub]);
      }

      if (!games.length) {
        return interaction.editReply("âŒ No games available today.");
      }

      const game = games[Math.floor(Math.random() * games.length)];
      const pick = bestOutcome(game);
      if (!pick) return interaction.editReply("âŒ No valid odds found.");

      return interaction.editReply({
        embeds: [
          new EmbedBuilder()
            .setTitle("ðŸŽ¯ Todayâ€™s Pick")
            .setDescription(`${game.home_team} vs ${game.away_team}`)
            .addFields(
              { name: "Pick", value: pick.name },
              { name: "Odds", value: pick.price.toString() },
              { name: "Source", value: sub.toUpperCase() }
            )
        ]
      });
    }

    /* ================= BUILD ================= */
    if (commandName === "build") {
      const legs = options.getInteger("legs") || 3;
      const bankroll = options.getInteger("bankroll") || 20;
      const mode = options.getString("mode") || "parlay";
      const live = options.getBoolean("live") || false;

      let games = [];
      for (const k in SPORTS) {
        games.push(...await fetchOdds(SPORTS[k]));
      }

      const picks = games
        .map(g => ({ game: g, pick: bestOutcome(g) }))
        .filter(p => p.pick)
        .slice(0, legs);

      if (!picks.length) {
        return interaction.editReply("âŒ No games available to build.");
      }

      const split = splitBankroll(bankroll, legs);

      const embed = new EmbedBuilder()
        .setTitle("ðŸ§± Parlay Builder")
        .setDescription(`${mode.toUpperCase()} â€¢ ${legs} Legs`);

      picks.forEach((p, i) => {
        embed.addFields({
          name: `Leg ${i + 1}`,
          value: `${p.pick.name} (${p.pick.price})`
        });
      });

      embed.addFields({
        name: "ðŸ’° Allocation",
        value:
          mode === "straight"
            ? `Straight Bet: $${split.straight}`
            : `
Straight: $${split.straight}
3-Leg: $${split.threeLeg}
Full Parlay: $${split.fullParlay}
`
      });

      return interaction.editReply({ embeds: [embed] });
    }

    /* ================= UNDERDOG ================= */
    if (commandName === "underdog") {
      const bankroll = options.getInteger("bankroll") || 20;

      let games = [];
      for (const k in SPORTS) {
        games.push(...await fetchOdds(SPORTS[k]));
      }

      const picks = games
        .map(g => ({ game: g, pick: bestOutcome(g) }))
        .filter(p => p.pick)
        .slice(0, 7);

      if (!picks.length) {
        return interaction.editReply("âŒ No underdog picks today.");
      }

      const split = splitBankroll(bankroll, 7);

      const embed = new EmbedBuilder()
        .setTitle("ðŸ”¥ Underdog Aggressive Strategy")
        .setDescription("Lucky 7 ðŸ€");

      picks.forEach((p, i) => {
        embed.addFields({
          name: `Leg ${i + 1}`,
          value: `${p.pick.name} (${p.pick.price})`
        });
      });

      embed.addFields({
        name: "ðŸ’° Bankroll Plan",
        value: `
Straight: $${split.straight}
3-Leg: $${split.threeLeg}
7-Leg Lotto: $${split.fullParlay}
`
      });

      return interaction.editReply({ embeds: [embed] });
    }

    /* ================= CALLEY ================= */
    if (commandName === "calley") {
      const sub = options.getSubcommand(false) || "math";

      if (sub === "math") {
        return interaction.editReply(
          "ðŸ“ Parlay Math: Multiply implied probabilities to estimate payout edge."
        );
      }

      if (sub === "today") {
        let games = [];
        for (const k in SPORTS) {
          games.push(...await fetchOdds(SPORTS[k]));
        }

        const picks = games
          .map(g => ({ game: g, pick: bestOutcome(g) }))
          .filter(p => p.pick)
          .slice(0, 5);

        if (!picks.length) {
          return interaction.editReply("âŒ No picks available.");
        }

        const embed = new EmbedBuilder()
          .setTitle("ðŸ¤– AI-Ranked Picks (Today)");

        picks.forEach((p, i) => {
          embed.addFields({
            name: `Pick ${i + 1}`,
            value: `${p.pick.name} (${p.pick.price})`
          });
        });

        return interaction.editReply({ embeds: [embed] });
      }
    }

  } catch (err) {
    console.error(err);
    return interaction.editReply("âš ï¸ Error handled safely. Bot is still live.");
  }
});

client.login(process.env.DISCORD_TOKEN);





  	DEPLOY-COMMAND-SCRIPT 





	
	
	
	
	
	
	
	
	
	
	
	
require("dotenv").config();
const { REST, Routes, SlashCommandBuilder } = require("discord.js");

const pick = new SlashCommandBuilder()
  .setName("pick")
  .setDescription("Get picks")
  .addSubcommand(s => s.setName("default").setDescription("Best overall pick"))
  .addSubcommand(s => s.setName("nba").setDescription("NBA pick"))
  .addSubcommand(s => s.setName("nfl").setDescription("NFL pick"))
  .addSubcommand(s => s.setName("nhl").setDescription("NHL pick"))
  .addSubcommand(s => s.setName("cfb").setDescription("College football pick"))
  .addSubcommand(s => s.setName("cbb").setDescription("College basketball pick"))
  .addSubcommand(s => s.setName("boxing").setDescription("Boxing pick"))
  .addSubcommand(s => s.setName("mma").setDescription("MMA pick"))
  .addSubcommand(s =>
    s.setName("query")
      .setDescription("Lookup any team or player")
      .addStringOption(o =>
        o.setName("search").setDescription("Search").setRequired(true)
      )
  );

const build = new SlashCommandBuilder()
  .setName("build")
  .setDescription("Build a parlay or straight bet")
  .addIntegerOption(o =>
    o.setName("legs").setDescription("Number of legs").setRequired(false)
  )
  .addIntegerOption(o =>
    o.setName("bankroll").setDescription("Bankroll").setRequired(false)
  )
  .addStringOption(o =>
    o.setName("mode")
      .setDescription("straight or parlay")
      .addChoices(
        { name: "Parlay", value: "parlay" },
        { name: "Straight", value: "straight" }
      )
  )
  .addBooleanOption(o =>
    o.setName("live").setDescription("Live games only")
  );

const underdog = new SlashCommandBuilder()
  .setName("underdog")
  .addIntegerOption(o =>
    o.setName("bankroll").setDescription("Bankroll").setRequired(false)
  );

const calley = new SlashCommandBuilder()
  .setName("calley")
  .setDescription("Parlay tools")
  .addSubcommand(s =>
    s.setName("math").setDescription("Parlay math calculator")
  )
  .addSubcommand(s =>
    s.setName("today").setDescription("AI-ranked picks today")
  );

const rest = new REST({ version: "10" }).setToken(process.env.DISCORD_TOKEN);

(async () => {
  await rest.put(
    Routes.applicationGuildCommands(
      process.env.CLIENT_ID,
      process.env.GUILD_ID
    ),
    { body: [pick, build, underdog, calley].map(c => c.toJSON()) }
  );
  console.log("âœ… Commands deployed cleanly");
})();

/* =======================
   AUTO POST (EVERY 30 MIN)
======================= */
cron.schedule('*/30 * * * *', async () => {
  const context = await buildOddsContext();
  if (!context.includes('vs')) return;

  const channel = client.channels.cache.find(c => c.name === 'picks');
  if (!channel) return;

  channel.send(`? **Live & Upcoming Games**\n${context}`);
});



/* =======================
   SPORT MAP (CRITICAL)
======================= */
const SPORT_MAP = {
  nba: 'basketball_nba',
  nfl: 'americanfootball_nfl',
  nhl: 'icehockey_nhl',
  ncaam: 'basketball_ncaam',
  ncaaf: 'americanfootball_ncaaf',
  epl: 'soccer_epl',
  mls: 'soccer_usa_mls'
};

